/*
 * Сhatty events
Болтливое событие - скрол, ресайсз, маусмув, дрег, инпут
 * Приемы throttling и debouncing c Lodash
 */
//Throttle  = рием throttle контролирует количество раз которое функция может быть вызвана в течение промежутка времени. То есть позволяет вызывать функцию не чаще чем один раз в N миллисекунд, гарантируя ее регулярное выполнение.
//Используя throttle мы не контролируем, как часто браузер будет генерировать события. Мы всего-лишь берем контроль над частотой выполнения функции обработчика события.
//Реализация из библиотеки Lodash ожидает первым аргументом функцию которую необходимо «затормозить», а вторым количество миллисекунд. Возвращает новую функцию для передачи в слушатель события.
/*
 * Mousemove и throttle
 */
const refsThrottle = {
  coordsOutput: document.querySelector('.js-coords'),
  mouseMoveCounter: 0,
  onMouseMove(event) {
    refsThrottle.mouseMoveCounter += 1;
    refsThrottle.coordsOutput.textContent = `
    Кол-во вызовов onMouseMove: ${refsThrottle.mouseMoveCounter};
    x: ${event.clientX},
    y: ${event.clientY},
    `;
  },
};
// const onMouseMoveThtotle = _.throttle(refsThrottle.onMouseMove, 250);
// функция из библиотеки лодеш, которая запускает нашу функцию отслеживания событий раз в 500мс (чтобы уберешь нас от болтливого события)
// window.addEventListener('mousemove', onMouseMoveThtotle);
/// запускаем функцию тротл из библиотеки лодеш
window.addEventListener('mousemove', _.throttle(refsThrottle.onMouseMove, 500));
// запускаем функцию тротл из библиотеки лодеш, которая запускает нашу функцию отслеживания событий раз в 500мс (чтобы уберешь нас от болтливого события)
//---------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------
/*
 * Input и debounce
 */

//Debounce = Прием debounce гарантирует, что функция будет вызвана только если между событиями будет пауза в N миллисекунд. Например, пока пользователь скролит страницу функция не вызовется, но как только он перестал скролить, функция будет вызвана через 300 миллисекунд. Если скролл возобновится раньше чем через 300 миллисекунд после паузы, функция не вызовется.
//Используя debounce мы не управляем тем как часто браузер будет генерировать события, а всего-лишь берем контроль над частотой выполнения функции обработчика события.

const refsdebounce = {
  input: document.querySelector('.js-input'),
  otput: document.querySelector('.js-output'),
  inputCounter: 0,
  onInputChange(event) {
    refsdebounce.inputCounter += 1;
    refsdebounce.otput.textContent = `
    Кол-во вызовов onInputChange: ${refsdebounce.inputCounter},
    Значение: ${event.target.value}
    `;
  },
};

refsdebounce.input.addEventListener('input', _.debounce(refsdebounce.onInputChange, 2000));
//запускаем функцию дебаунс из библиотеки лодеш, которая запускает нашу функцию отслеживания событий спустя 2с простоя (чтобы уберешь нас от болтливого события), удобно для реализации живого поиска
